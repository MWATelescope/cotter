#include "subbandpassband.h"

#include <cmath>
#include <iostream>

const double* SubbandPassband::_sb128ChannelSubbandValue = SubbandPassband::_sb128ChannelSubbandValue2014FromMemo;
//const double* SubbandPassband::_sb128ChannelSubbandValue = SubbandPassband::_sb128ChannelSubbandValue2013;

/**
 * These are the subband values that were measured by Offringa using
 * one of the MWA 32-tiles commissioning arrays somewhere
 * around the beginning of 2013. Measured from 5 min of data on a calibrator,
 * then stacked all subbands on top of each other and normalized the median to unity.
 */
const double SubbandPassband::_sb128ChannelSubbandValue2013[128] =
{
	0.573217601898, 0.576965449603, 0.583721429577, 0.599036303272, 
	0.614325905533, 0.6336174219125, 0.654694159511, 0.6795589236475, 
	0.7012226336105, 0.728659372234, 0.7622932599755, 0.7917312896425, 
	0.811318790974, 0.837125962681, 0.8647183466755, 0.889561348969, 
	0.9087621483585, 0.9328190325905, 0.9466686133875, 0.959987177829, 
	0.9737477236515, 0.986389554444, 0.9926438181315, 1.000824466675, 
	1.00751947671, 1.01344888694, 1.015032664965, 1.016217387975, 
	1.017019906285, 1.0179998133, 1.0199285733, 1.02150194221, 
	1.015433715735, 1.01734944675, 1.01767867002, 1.017609149795, 
	1.010118499885, 1.013291160375, 1.00849455475, 1.011864746005, 
	1.01016123152, 1.013727428075, 1.013199875415, 1.00969793698, 
	1.01410693763, 1.011731997545, 1.01194835154, 1.01519301152, 
	1.00634039788, 1.008700178655, 1.010636365145, 1.011232669385, 
	1.01773218687, 1.009325626785, 1.01229792348, 1.008074142135, 
	1.01278668183, 1.00586710233, 1.008963290385, 1.006333203095, 
	1.00694053268, 1.00274513021, 1.009379911625, 0.9975093954145, 
	1.0, 0.9903078859775, 1.009405713445, 1.00218046696, 
	1.00463322266, 1.00680999077, 1.006044230685, 1.004589267045, 
	1.006145278635, 1.0000605658595, 1.004020178275, 1.00597123479, 
	1.0010107667695, 1.00262310025, 1.002385878891, 1.003420541785, 
	1.00202783333, 1.0039062566, 0.9989457385485, 1.007110902925, 
	0.9995393878385, 0.999590215089, 1.00144454535, 0.999126364441, 
	1.000522686671, 0.9998788994945, 0.996176776542, 0.9986661030665, 
	1.0009725888075, 0.9973176262505, 0.998037459566, 1.00093665108, 
	1.00086265322, 0.9976263040965, 1.000821775465, 0.9968827101945, 
	1.0004309623695, 1.001735065047, 0.9925167855925, 0.992450577974, 
	0.987678656449, 0.978902214838, 0.971239782556, 0.959048142981, 
	0.949989137813, 0.939058180973, 0.923218701936, 0.9063929357545, 
	0.885737746588, 0.8661544281875, 0.8413941778095, 0.820668554225, 
	0.791733245076, 0.7652937362675, 0.741346123595, 0.7116831355165, 
	0.686855659109, 0.664213195122, 0.639235464865, 0.621399944043, 
	0.6035409417765, 0.587319921016, 0.5799810078305, 0.5755895188925
};

/**
 * These are subband values coming from an old Levine MWA memo, where they
 * are derived from the poly phase filter coefficients. Nichole Barry mailed
 * me these values: she tested them against the '2013' values above.
 * Initially, these were mirrored, because the 64th sample was unity, instead
 * of the 65th. 
 */
const double SubbandPassband::_sb128ChannelSubbandValue2014FromMemo[128] =
{
	0.5002092286,
	0.5025463233, 0.5095006003, 0.5209000511, 0.5364655027,
	0.5558210624, 0.578507908, 0.6040009198, 0.6317276705,
	0.6610877352, 0.6914726388, 0.7222853397, 0.7529582567,
	0.7829676164, 0.811847953, 0.8392006276, 0.8647014754,
	0.8881031286, 0.9092359525, 0.9280049655, 0.9443854775,
	0.9584152159, 0.9701859925, 0.9798348905, 0.9875338705,
	0.9934801632, 0.9978861616, 1.0009717022, 1.0029560443,
	1.0040506, 1.0044541097, 1.0043486497, 1.0038957138,
	1.0032352887, 1.0024841158, 1.0017360425, 1.0010627468,
	1.0005145298, 1.0001227353, 0.9999016844, 0.9998508036,
	0.9999576333, 1.0002001147, 1.0005493174, 1.0009719327,
	1.0014325423, 1.0018965935, 1.0023317792, 1.0027098934,
	1.003007776, 1.0032087236, 1.003302975, 1.0032879588,
	1.003166914, 1.0029505018, 1.0026535597, 1.0022962373,
	1.0019012075, 1.001492497, 1.0010952483, 1.0007327206,
	1.0004265297, 1.0001941268, 1.0000490463, 1.0,
	1.0000490463, 1.0001941268, 1.0004265297, 1.0007327206,
	1.0010952483, 1.001492497, 1.0019012075, 1.0022962373,
	1.0026535597, 1.0029505018, 1.003166914, 1.0032879588,
	1.003302975, 1.0032087236, 1.003007776, 1.0027098934,
	1.0023317792, 1.0018965935, 1.0014325423, 1.0009719327,
	1.0005493174, 1.0002001147, 0.9999576333, 0.9998508036,
	0.9999016844, 1.0001227353, 1.0005145298, 1.0010627468,
	1.0017360425, 1.0024841158, 1.0032352887, 1.0038957138,
	1.0043486497, 1.0044541097, 1.0040506, 1.0029560443,
	1.0009717022, 0.9978861616, 0.9934801632, 0.9875338705,
	0.9798348905, 0.9701859925, 0.9584152159, 0.9443854775,
	0.9280049655, 0.9092359525, 0.8881031286, 0.8647014754,
	0.8392006276, 0.811847953, 0.7829676164, 0.7529582567,
	0.7222853397, 0.6914726388, 0.6610877352, 0.6317276705,
	0.6040009198, 0.578507908, 0.5558210624, 0.5364655027,
	0.5209000511, 0.5095006003, 0.5025463233
};

void SubbandPassband::GetSubbandPassband(std::vector<double>& passband, std::size_t channelsPerSubband)
{
	passband.resize(channelsPerSubband);
	
	for(std::size_t ch=0; ch!=channelsPerSubband; ++ch)
		passband[ch] = getSubbandValue(ch, channelsPerSubband);
}

double SubbandPassband::getSubbandValue(std::size_t channel, std::size_t channelCount)
{
	if(channelCount == 128)
		return _sb128ChannelSubbandValue[channel];
	
	const double integrationSize =
		128.0 / channelCount;
	const double channel128 = channel * integrationSize + 0.5 * integrationSize - 0.5;
	if(integrationSize < 1.0)
		return _sb128ChannelSubbandValue[(std::size_t) round(channel128)];
	else {
		double
			startChannel = channel128 - integrationSize * 0.5,
			endChannel = channel128 + integrationSize * 0.5;
		if(startChannel < 0.0)
			startChannel = 0.0;
		if(endChannel >= 127.0)
			endChannel = 127.0;
		std::size_t
			startIndex = std::size_t(startChannel) + 1,
			endIndex = std::size_t(endChannel) + 1;
		
		double integratedValue = 0.0;
		for(std::size_t ch=startIndex; ch!=endIndex; ++ch)
		{
			integratedValue += _sb128ChannelSubbandValue[ch];
		}
		return integratedValue / (endIndex - startIndex);
	}
}
